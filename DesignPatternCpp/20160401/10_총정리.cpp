// 총정리

// 디자인 패턴의 핵심 (설계의 원리)
// 1. 공통성과 가변성의 분리 - 변하지 않는 전체 알고리즘에서 변하는 것을 뽑아내는 것.
//	A. 변하는 것을 가상함수로 분리 - 자식 클래스에서 가상함수를 재정의
//		"Template Method Pattern": 알고리즘이나 정책을 변경
//		"Factory Method Pattern": 어떤 클래스의 인스턴스를 생성할지를 결정
//		"편리하지만, 정적인 변화 - 실행시간에 변경 불가"		- 상속을 이용하기 때문
//		"정책을 다른 클래스에서 재사용하는 것이 불가능하다."

//	B. 변하는 것을 다른 클래스로
//		- 교체 가능해야 하므로 인터페이스 기반으로
//		"Strategy"	: 알고리즘의 캡슐화
//		"State"		: 상태에 따른 동작의 변경
//		"Builder"	: 같은 공정이지만 다른 표현의 객체를 생성할 때 
//				- 다른 형태로 사용되는 경우가 많다. 생성자, 불변객체
//		"실행 시간에 교체 가능하다. 정책을 다른 클래스에서 재사용하다."

//		- 템플릿 인자를 통한 정책 클래스의 교체 방법
//			실행시간에 교체는 불가능하지만 인라인 치환이 가능하므로 성능이 높다.
//			stack<int, list<int>> / List<int, SingleThread>

// 2. 간접층을 도입함으로서 문제를 해결하는 패턴
//	- Adapter: 클라이언트가 요구하는 클래스를 기존 클래스의 인터페이스를 변경해서 제공
//	- Proxy: 기존 요소를 대신하는 클래스 (Remote Proxy, Smart Proxy)
//	- Bridge: 구현부와 추상부를 독립적으로 변경 가능하게 하겠다.
//	- Facade: 하위 시스템의 복잡함을 단순화 해주는 개념
//	- Mediator: 복잡한 객체 간의 관계를 단순화 시킨다.
//	- Command: 명령을 추상화 - undo, redo, macro (명령을 객체로 래핑)

// 3. A와 B를 묶기 위해서는 공통의 부모가 필요하다.
//	- 재귀적 합성을 사용한 패턴 2가지
//	- Composite: 재귀적 합성을 통한 복합 객체의 구성
//	- Decorator: 재귀적 합성을 통한 기능의 추가

// 4. 복합 객체(컨테이너) 연관된 패턴 2가지
//	- Iterator: 복합객체의 내부 구조에 상관없이 요소를 열거
//	- Visitor: 복합객체의 내부 구조에 상관없이 요소에 연산

// 5. 이벤트 처리에 관련된 패턴 2가지
//	- Observer: 이벤트가 발생하였을 경우 등록된 객체에게 전파
//	- Chain of Responsibility: "		다음 객체에게 전파

// 6. C++ idioms
//	- RAII, CRTP, STL, algorithm, function, thin template (임베디드 컨테이너 설계), 통보 센터



//--------------------------------------------------------

// 디자인 패턴의 23가지
// 생성 5가지: 싱글톤, 추상팩토리, 팩토리 메소드, 빌더, 프로토 타입
//		싱글톤: 멀티스레드 안정성을 어떻게 해결하고 있나?
//		프로토 타입: 객체 복제에 다형성 이용
// 구조 7가지: 어댑터, 프록시, 브릿지, 퍼사드, 컴포지드, 데코레이터, 플라이웨이트
//		플라이웨이트: 불변 객체로 써야만 한다. 그래야 공유할 수 있다.
// 행위 11가지: 반복자, 방문자,			- 컨테이너
//				관찰자, 책임의전가,		- 이벤트
//				템플릿메소드, 전략, 상태, 
//				커맨드, 메멘토, 중재자, 인터프리터

// 결국 가장 중요한 것은 객체 지향의 5대 원칙 SOLID
// SRP (단일 책임의 원칙) : 모듈은 단 하나의 책임을 가져야 한다.
// OCP (계방 폐쇄의 원칙) : 새로운 기능이 추가되어도 확장에는 열려있어야 한다.
// LSP (리스코프 치환 원칙) : 자식의 공통된 긴으은 부모로부터 와야 한다.
// ISP (인터페이스 분리 원칙) : 범용 인터페이스 보다는 세분화된 인터페이스가 낫다.
// DIP (의존 관계 역전원칙) - 클라이언트는 구체 클래스에 의존하는 것이 아니라 인터페이스나 추상 클래스에 의존해야 한다.

// 단위테스트 관점에서도 SOLID로 설명
