// 공통성과 가변성의 분리 - C++ 알기 쉬운 디자인 패턴 (옛날 책이라 좋지도 않다.)

// 변하지 않는 것(공통성, 전체 알고리즘)에서 변하는 것 (가변성, 정책)을 분리하는 4가지 기술

// 1. 일반 함수에서 변해야 하는 정책
//	=> 변하는 것을 함수 인자화 한다.
//		=> 함수 포인터
//	=> 성능을 고려한다면 함수 포인터 대신 함수 객체 사용. 단, 코드 메모리 증가
//	=> C++11 람다
//	=> STL이 이 방식을 많이 쓴다.

// 2. 멤버 함수에서 변해야 하는 정책
//	A. 변하는 것을 가상함수화 한다.
//		=> 자식 클래스를 만들면서 재정의
//		=> Temaplate method 패턴
//		=> 실행 시간에 정책을 변경하는 것이 불가능하다.
//		=> 정책을 다른 클래스에서 재사용하는 것이 불가능하다.
//		=> 간단하다.

//	B. 변하는 것을 인터페이스 기반 다른 클래스로
//		=> 인터페이스 기반 정책 클래스를 사용
//		=> Strategy 패턴
//		=> 실행 시간에 정책을 변경하는 것이 가능하다.
//		=> 정책의 재 사용성이 좋다.

// 3. 실행 시간에 정책을 변경할 필요가 없다면
//		=> 변하는 것을 템플릿 인자로 한다. (단위 전략)
//		=> 인라인 치환이 가능: 속도가 빠르다.
//		=> 실행 시간에 교체가 불가능 하다.
