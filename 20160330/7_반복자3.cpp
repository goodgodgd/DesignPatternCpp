// 반복자(Iterator) : GoF's Design Pattern
// 의도:  컨테이너의 내부 구조에 상관없이 요소를 열거할 수 있는 패턴

// vector<int>::iterator p = v.begin();
//	- generic interface
//	- 일반적 프로그래밍(알고리즘)
// 장점: 모든 것이 정적 바인딩 기반의 함수 이므로 인라인화 가능하다.
//		성능이 좋다.
// 단점: 내부의 모든 약속이 코드로 드러나지 않기 때문에, 문제가 발생하였을 경우 문제의 원인을 찾기 어렵다.

// Iterator<Interger> p = arr.iterator();
// 장점: 인터페이스 코드를 통해 약속되므로, 쉽게 사용 가능하다.
// 단점: 가상 함수 기반으로 동작하기 때문에, 성능저하가 있다.
//		모든 컬렉션이 동일한 메소드를 제공해야 한다는 중복이 발생한다.

// Java - Collections -> sort, find 를 static 함수로 제공 C++의 <algorithm> 기능과 비슷

// C++ 진영의 다형성

// 실행 시간 다형성 
// 일반적인 작업에 더 보편적으로 사용됨
// 장점: 여러 동물을 전달해도 함수는 하나이다.
// 단점: 가상 함수 기반. 느리다.
void foo(Animal* p) { p->cry(); }

// 컴파일 시간 다형성 
// 라이브러리에서 많이 사용, 성능 중요
// T에는 cry()가 있어야 한다는 사전 약속이 필요
// 장점: 인라인화 가능하다. 빠르다.
// 단점: 여러 동물을 보내면 foo()는 여러개 생성된다. 코드 메모리 부하가 있다.
template <typename T>
void foo(const T& p) { p.cry(); }